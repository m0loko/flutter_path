// type_system.dart

/*
Типы и особенности языка Dart
*/

// =============================================================================
// 1. Является ли Dart объектно-ориентированным языком?
// =============================================================================

/*
Теория:
Dart - объектно-ориентированный язык программирования.

Суть:
В Dart всё является объектом. Объекты - экземпляры классов, 
которые могут содержать данные (поля) и код (методы). 
Dart поддерживает основные принципы ООП: 
инкапсуляцию, наследование, полиморфизм и абстракцию.
*/

// Мини-шпаргалка:
// "Да, Dart - объектно-ориентированный язык, потому что всё является объектом, 
// и он поддерживает инкапсуляцию, наследование, полиморфизм и абстракцию".

// Пример кода:
void main() {
  Function myFunc = (int x) => x * 2;
  print(myFunc.runtimeType); // Closure (даже функция - это объект)
  print(123 is Object); // true (число - это объект)
}

// =============================================================================
// 2. Модификаторы доступа в Dart
// =============================================================================

/*
Теория:
В Dart есть только один модификатор доступа - private.

Суть:
Приватные поля и методы обозначаются символом "_" (подчеркивание) перед именем. 
Они видны только внутри библиотеки (файла), в котором объявлены.
*/

// Мини-шпаргалка:
// "В Dart есть только private (подчеркивание). Он действует на уровне файла".

// Пример кода:
class MyClass {
  String _privateField = "Secret"; // private
  String publicField = "Public"; // public
}

class AnotherClass {
  void printPrivate(MyClass obj) {
    print(obj._privateField); // OK: в том же файле
  }
}

// =============================================================================
// 3. final vs const
// =============================================================================

/*
Теория:
final и const используются для объявления переменных, которые нельзя изменить после инициализации. 
Ключевое различие в том, когда происходит инициализация, а также в возможностях оптимизации, 
которые предоставляются компилятору.

*   final: Значение определяется во время выполнения (runtime), но только один раз. 
    После присваивания значения final переменной, его нельзя изменить.
*   const: Значение должно быть известно во время компиляции. 
    Это константа времени компиляции. const переменные также являются final, 
    но с дополнительными ограничениями.

Дополнительные особенности const:
1.  const переменные могут быть только примитивными типами (int, double, String, bool) или коллекциями, 
    содержащими только const значения.
2.  const может использоваться для создания константных экземпляров классов. 
    Для этого класс должен иметь const конструктор.
3.  const значения подвергаются "interning" - оптимизации, при которой все переменные 
    с одинаковыми const значениями указывают на одну и ту же область памяти.
*/

// Мини-шпаргалка:
// "const - compile-time константа (известна при компиляции), final - runtime константа (известна во время выполнения).
// const позволяет компилятору оптимизировать код и экономить память за счет "interning"".

// Пример кода:
void main() {
  // const:
  const pi = 3.14; // compile-time константа
  const area = pi * 5 * 5; // compile-time вычисление

  // final:
  final currentTime =
      DateTime.now(); // runtime константа (значение известно только во время выполнения)

  // "Interning" (экономия памяти):
  const a = "hello";
  const b = "hello";
  print(
    identical(a, b),
  ); // true (a и b указывают на одну и ту же область памяти)

  final c = "hello";
  final d = "hello";
  print(identical(c, d)); // false (c и d указывают на разные области памяти)

  // const constructor:
  const myPoint = MyPoint(10, 20);
  const myPoint2 = MyPoint(10, 20);
  print(identical(myPoint, myPoint2)); // true (один и тот же объект)

  // Изменение final List:
  final myList = [1, 2, 3];
  myList.add(4); // OK: можно менять содержимое списка
  print(myList); // [1, 2, 3, 4]
  // myList = [4, 5, 6]; // Ошибка: нельзя переприсвоить final переменную

  // const List - нельзя менять
  const myConstList = [1, 2, 3];
  // myConstList.add(4); // Ошибка: Cannot modify an unmodifiable list
}

class MyPoint {
  final int x, y;
  const MyPoint(this.x, this.y); // const конструктор
}

// =============================================================================
// 4. Object vs dynamic vs var
// =============================================================================

/*
Теория:
Object, dynamic и var используются для объявления переменных, но с разными уровнями статической типизации:

*   Object: Базовый тип для всех объектов. Ограничивает доступ к базовым методам.
*   dynamic: Отключает статическую проверку типов. Ошибки только в runtime.
*   var: Автоматический вывод типа.
*/

// Мини-шпаргалка:
// "Object - базовый тип, dynamic - отключает типы, var - автоматический вывод типа".

// Пример кода:
Object myObject = 123;
dynamic myDynamic = "hello";
var myVar = 123; // int

// =============================================================================
// 5. Именованные конструкторы
// =============================================================================

/*
Теория:
Именованный конструктор - это конструктор с уникальным именем.

Суть:
Позволяет создавать объекты разными способами, с разной логикой инициализации.
*/

// Мини-шпаргалка:
// "Именованные конструкторы - это как несколько "точек входа" для создания объекта".

// Пример кода:
class Point {
  double x, y;

  Point(this.x, this.y); // Обычный

  Point.origin() : x = 0, y = 0; // Именованный
}

// =============================================================================
// 6. Factory Constructors
// =============================================================================

/*
Теория:
Factory Constructor - это конструктор, который *не всегда* создает новый экземпляр класса.

Суть:
Позволяет управлять созданием объектов, возвращать подтипы, кэшированные экземпляры и т.д.
*/

// Мини-шпаргалка:
// "Factory Constructor - это гибкий способ создавать объекты, иногда возвращая существующие".

// Пример кода:
class Logger {
  static final Logger _instance = Logger._internal();
  factory Logger() => _instance;
  Logger._internal();
  void log(String msg) => print(msg);
}

// =============================================================================
// 7. Интерфейсы в Dart
// =============================================================================

/*
Теория:
До Dart 3.0 не было ключевого слова interface. Любой класс был интерфейсом.
В Dart 3.0 появился `interface class`.

Суть:
`interface class` позволяет явно определить интерфейс, запретив наследование реализации.
*/

// Мини-шпаргалка:
// "В Dart 3 появился `interface class` для явного определения интерфейсов".

// Пример кода:
interface class MyInterface {
  void doSomething();
}

// =============================================================================
// 8. extends vs implements
// =============================================================================

/*
Теория:
*   extends: Наследование. Создает отношение "IS-A". Наследует интерфейс и реализацию.
*   implements: Реализация интерфейса. Создает отношение "CAN-DO". Реализует интерфейс, но не наследует реализацию.
*/

// Мини-шпаргалка:
// "extends - IS-A, implements - CAN-DO".

// Пример кода:
class Animal {
  void makeSound() => print("Generic");
}

class Dog extends Animal {
  @override
  void makeSound() {
    super.makeSound(); // вызов родительского метода
    print("Woof!");
  }
}

interface class Swimmer {
  void swim();
}

class Fish implements Swimmer {
  @override
  void swim() => print("Swimming");
}

// =============================================================================
// 9. Mixins
// =============================================================================

/*
Теория:
Mixins - способ переиспользования кода в нескольких классах, не связанных иерархией наследования.

Суть:
Позволяет "подмешивать" функциональность в классы, избегая множественного наследования.
*/

// Мини-шпаргалка:
// "Mixins - это как "строительные блоки" для добавления функциональности в классы".

// Пример кода:
mixin Loggable {
  void log(String msg) => print("LOG: $msg");
}

class MyWidget with Loggable {
  void doSomething() {
    log("Did something");
  }
}