// dart_fundamentals.dart

/*
Основы Dart: Типы данных, Коллекции, Управляющие конструкции, Исключения, Generics, Null-safety
*/

// =============================================================================
// 1. Типы данных (Data Types)
// =============================================================================

/*
Теория:
Dart - язык со статической типизацией (static typing), но с возможностью вывода типов (type inference).

Основные встроенные типы:
1.  int: Целые числа.
2.  double: Числа с плавающей точкой.
3.  bool: Логические значения (true/false).
4.  String: Строки.
5.  List: Списки (массивы).
6.  Map: Словари (ключ-значение).
7.  Set: Множества (уникальные значения).
8.  Runes: Unicode символы.
9.  Symbol: Символы (идентификаторы).
10. Null: Тип, представляющий отсутствие значения.

*/

// Мини-шпаргалка:
// "int, double, bool, String, List, Map, Set, Runes, Symbol, Null"

// Пример кода:
void main() {
  int age = 30;
  double height = 1.75;
  String name = "John Doe";
  List<int> numbers = [1, 2, 3];
  Map<String, dynamic> person = {"name": name, "age": age};
}

// =============================================================================
// 2. Dart Collections
// =============================================================================

/*
Теория:
Dart предоставляет несколько типов коллекций для хранения данных:

1.  List: Упорядоченный список элементов. Допускает дубликаты.
2.  Set: Неупорядоченное множество уникальных элементов. Не допускает дубликаты.
3.  Map: Коллекция пар "ключ-значение". Ключи должны быть уникальными.
4.  Queue: Очередь (First-In-First-Out).
*/

// Мини-шпаргалка:
// "List (упорядоченный), Set (уникальный), Map (ключ-значение), Queue (очередь)"

// Пример кода:
void main() {
  List<String> names = ["Alice", "Bob", "Charlie", "Alice"];
  Set<String> uniqueNames = {"Alice", "Bob", "Charlie"};
  Map<String, int> ages = {"Alice": 25, "Bob": 30, "Charlie": 35};
}

// =============================================================================
// 3. How is Map arranged? What are hash tables?
// =============================================================================

/*

// =============================================================================
// 4. Dart constrictions (Условные конструкции)
// =============================================================================

/*
Теория:
Dart предоставляет следующие условные конструкции:

1.  if/else: Выполнение кода в зависимости от условия.
2.  switch/case: Выбор одного из нескольких вариантов выполнения.
3.  Тернарный оператор (?:): Краткая форма записи if/else для простых случаев.
*/

// Мини-шпаргалка:
// "if/else, switch/case, тернарный оператор"

// Пример кода:
void main() {
  int age = 20;
  if (age >= 18) {
    print(" совершеннолетний");
  } else {
    print("несовершеннолетний");
  }

  String message = age >= 18 ? " совершеннолетний" : "несовершеннолетний"; // Тернарный оператор

  switch (age) {
    case 18:
      print("18 лет");
      break;
    default:
      print("Возраст: $age");
  }
}

// =============================================================================
// 5. Cascade operator and Spread operator
// =============================================================================

/*
Теория:
Dart предоставляет операторы, упрощающие работу с объектами и коллекциями:

1.  Каскадный оператор (..): Позволяет вызывать несколько методов одного объекта последовательно, без повторного упоминания имени объекта.
2.  Spread operator (...): Позволяет "развернуть" элементы одной коллекции в другую.
*/

// Мини-шпаргалка:
// ".. (каскад), ... (spread)"

// Пример кода:
void main() {
  // Cascade operator
  var person = Person()
    ..name = "John"
    ..age = 30
    ..printInfo();

  // Spread operator
  var list1 = [1, 2, 3];
  var list2 = [0, ...list1, 4, 5]; // [0, 1, 2, 3, 4, 5]
}

class Person {
  String? name;
  int? age;

  void printInfo() {
    print("Name: $name, Age: $age");
  }
}

// =============================================================================
// 6. Exception Handling
// =============================================================================

/*
Теория:
Обработка исключений - это механизм, позволяющий обрабатывать ошибки, возникающие во время выполнения программы, 
и предотвращать её аварийное завершение.

Конструкции для обработки исключений:

1.  try/catch: Позволяет перехватывать исключения определенного типа.
2.  try/on: Позволяет перехватывать исключения разных типов с разными обработчиками.
3.  finally: Блок кода, который выполняется всегда (независимо от того, было ли исключение или нет).
*/

// Мини-шпаргалка:
// "try/catch, try/on, finally"

// Пример кода:
void main() {
  try {
    int result = 10 ~/ 0; //  целочисленное деление, может выбросить исключение
    print("Result: $result");
  } catch (e) {
    print("Error: $e");
  } finally {
    print("Finally block"); // Выполнится всегда
  }
}

// =============================================================================
// 7. What is the difference between Exception and Error?
// =============================================================================

/*
Теория:
Exception и Error - это два разных типа объектов, представляющих разные виды проблем:

1.  Exception: Представляет собой исключительную ситуацию, которую программа может обработать (например, отсутствие файла, неверный формат данных).
2.  Error: Представляет собой серьезную проблему, которую программа обычно не может обработать (например, нехватка памяти, ошибка в виртуальной машине).

*/

// Мини-шпаргалка:
// "Exception - можно обработать, Error - обычно нет"

// =============================================================================
// 8. What is 'finally' keyword for?
// =============================================================================

/*
Теория:
Блок `finally` выполняется всегда, независимо от того, было ли исключение или нет.

Суть:
Он используется для выполнения кода, который должен быть выполнен в любом случае 
(например, закрытие файла, освобождение ресурсов).
*/

// Мини-шпаргалка:
// "finally - выполняется всегда (закрыть файл, освободить ресурсы)"

// Пример кода:
void main() {
  try {
    // ...
  } catch (e) {
    // ...
  } finally {
    print("This will always be printed");
  }
}

// =============================================================================
// 9. Generics
// =============================================================================

/*
Теория:
Generics (обобщения) - это механизм, позволяющий писать код, работающий с разными типами данных, 
не указывая конкретный тип заранее.

Суть:
Повышают переиспользуемость кода и безопасность типов.
*/

// Мини-шпаргалка:
// "Generics - переиспользуемый код с безопасностью типов"

// Пример кода:
class DataHolder<T> {
  T data;
  DataHolder(this.data);
}

void main() {
  DataHolder<int> intHolder = DataHolder(123);
  DataHolder<String> stringHolder = DataHolder("hello");
}

// =============================================================================
// 10. Why can't we replace Generic with dynamic
// =============================================================================

/*
Теория:
Хотя dynamic позволяет передавать любые типы, он отключает статическую проверку типов.

Суть:
Generics обеспечивают типобезопасность на этапе компиляции, dynamic - нет.
*/

// Мини-шпаргалка:
// "Generics - проверка типов при компиляции, dynamic - только во время выполнения"

// Пример кода:
void processData<T>(T data) {
  // Компилятор знает, что data имеет тип T
  print(data.runtimeType);
}

void processDataDynamic(dynamic data) {
  // Компилятор не знает, какой тип у data
  // data.someMethod(); // Может упасть во время выполнения
}

// =============================================================================
// 11. Null Safety
// =============================================================================

/*
Теория:
Null Safety - это функция Dart, которая помогает предотвратить ошибки, связанные с null значениями.

Суть:
Dart требует явного указания, может ли переменная быть null или нет.
*/

// Мини-шпаргалка:
// "Null Safety - защита от NullPointerException"

// Пример кода:
String? name = null; // Может быть null
String name2 = "John"; // Не может быть null

// =============================================================================
// 12. Bang operator
// =============================================================================

/*
Теория:
Bang operator (!) - это оператор "force unwrap", который говорит компилятору: 
"Я уверен, что эта переменная не равна null".

Суть:
Использовать с осторожностью, т.к. если переменная все-таки равна null, программа выбросит исключение.
*/

// Мини-шпаргалка:
// "Bang operator (!) - force unwrap (опасно!)"

// Пример кода:
String? nullableName;
// String name = nullableName!; // Опасно! Если nullableName == null, будет ошибка

// =============================================================================
// 13. What other operators are used to work with nullsafety
// =============================================================================

/*
Теория:
1.  ?.: Условный вызов метода (если объект не null).
2.  ??: Оператор "если null" (возвращает значение справа, если слева null).
3.  ??=: Оператор присваивания "если null" (присваивает значение справа, если слева null).
*/

// Мини-шпаргалка:
// "?. (условный вызов), ?? (если null), ??= (присвоить если null)"

// Пример кода:
String? name;
print(name?.toUpperCase()); // null (не будет ошибки, если name == null)
String defaultName = name ?? "Guest"; // "Guest" (если name == null)
name ??= "Default"; // name = "Default" (если name == null)

// =============================================================================
// 14. Is it possible to initialize a non-null variable and not give it a value? By what mechanism is this feasible and what problems might arise?
// =============================================================================

/*
Теория:
Да, это возможно с помощью ключевого слова `late`.

Суть:
`late` позволяет объявить переменную, которая не инициализируется сразу при создании объекта. 
Инициализация произойдет позже, перед первым использованием переменной.

Проблемы:
Если обратиться к `late` переменной до её инициализации, будет выброшено исключение `LateInitializationError`.
*/

// Мини-шпаргалка:
// "late - отложенная инициализация (опасно: LateInitializationError)"

// Пример кода:
class MyClass {
  late String name;

  void initialize() {
    name = "Initialized"; // Инициализация происходит позже
  }

  void printName() {
    // print(name); // Ошибка, если initialize() не был вызван
  }
}