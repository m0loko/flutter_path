/*
S - single responsobility 
      у класса должна быть только одна причина для изменнеия
      мы хотим собрать вместе то, что менятеся по одним причинам и разделить то, что меняется по разным причинам
        преимущество: делает код более понятным по типу более понятное название и тд, помогает упростить обслуживание и легче тестировать
  логика аутнификации может измениться из-за обновлений системы безопасности
  логика управления профилем может измениться из-за обновления способа хранения данный
 */
//BAD
class UserManager {
  void authUser() {
    print('регаю юзера');
  }

  void updateUserProfile() {
    print('обновляю фотку ');
  }
}

//GOOD
class AuthManager {
  void authUser() {
    print('регаю юзера');
  }
}

class ProfileManager {
  void updateUserProfile() {
    print('обновляю фотку ');
  }
}

///////////////////////////////////////////////////

/* 
O - Open closed 
    Программные сущности(классы,функции и тд.) должны быть открыты для расширения, но закрыты для изменения
    я и команда должны добавлять какие-то функции в нашу программу не изменяя существующий код
ну к примеру есть у меня класс фигура и класс расчёта площади (и тут я свитчом проверяю какая фигура) и в зависимости от фигуры я рассчитываю площадь
нужно сделать базовый интерфейс с методом для расчёта площади , а остальные классы переопределяют этот метод 
      преимущество: этот принцип позволяет легко расширять системы новыми функциями без изменения существующего кода и снижает риск появления ошибок и придерживаемся
      шаблонов проектирования . он поощряет создание интефрейсов(это контракты для классов, которые будут их реализовывать)
 */

///////////////////////////////////////////////////

/* 
L - Liskov substitution Principle
объекты суперкласса должны быть заменяемы объектами его подклассами без ущерба для корректности программы
тут Lion является подтипом  Animal, то объекты типа Animal могут быть заменены объектами типа Lion без изменения желаемого поведения программы
похож впринципе на наследование, но говорит больше о том как следует использовать наследование для поддержания коректности программы и ообеспечения заменяемсоти объекта
простое наледование от супера не гарантирует, что код соотвествует LSP
    преимущество: каждый класс можно рассматривать как отдельный модуль, т.е. его можно разрабатывать и тестировать независимо от других классов. это способствует модульности 
    также можем быть уверенными, что каждый класс в группе ведёт себя последовательно.
Чтобы лучше понять LSP, обычно приводят пример нарушения. Например: класс Ostrich (Страус) наследуется от Bird, 
но в методе fly() выбрасывает ошибку UnimplementedError. Это нарушение LSP, потому что мы не можем заменить Bird на
Ostrich без риска поломать программу. Твой пример — это правильное использование, что тоже хорошо.
*/

abstract class Animal {
  void makeSound();
}

class Lion extends Animal {
  @override
  void makeSound() {
    print('Roar');
  }
}

void makeAnimalSound(Animal animal) {
  animal.makeSound();
}

void main() {
  Animal animal = Lion();
  makeAnimalSound(animal);

  Lion lion = Lion();
  makeAnimalSound(lion);
}

///////////////////////////////////////////////////

/* 
I - Interface Segregation Principle 
  клиенты не должны зависеть от методов, которые они НЕ используют
  интерфейсы должны быть простыми
  если реализации содержат пустые методы это оначает что ISP не соблюдается 
 */

///////////////////////////////////////////////////

/* 
D - Dependency Inversion Principle
это стротегия прри которой зависимости строятся на интерфейсах или абстрактных функция и классах
если компоненты системы зависят друг от друга мы не хотим напрямую внедрять зависимости одного компонента в другой , вместо этого мы должны использовать уровень абстракции между ними

 */
